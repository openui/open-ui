---
menu: Active Proposals
name: Scoped Focusgroup (Explainer)
path: /components/scoped-focusgroup.explainer
layout: ../../layouts/ComponentLayout.astro
---

 - Authors: [Jacques Newman](https://github.com/janewman)
 - Prior contributors (from the earlier, broader [focusgroup explainer](/components/focusgroup.explainer)): [Travis Leithead](https://github.com/travisleithead), [David Zearing](https://github.com/dzearing), [Chris Holt](https://github.com/chrisdholt)
 - Last updated: 2025-08-15

## Table of Contents

- [Introduction](#introduction)
- [Differences from the original explainer](#differences-from-the-original-explainer)
  - [CSS Support is now a future consideration.](#css-support-is-now-a-future-consideration)
  - [Grid Support is now a future consideration.](#grid-support-is-now-a-future-consideration)
  - [Focusgroup is now scoped to specific Scenarios](#focusgroup-is-now-scoped-to-specific-scenarios)
  - [Eligible Roles](#eligible-roles)
- [Quickstart](#quickstart)
- [Goal](#goal)
  - [Non-Goals](#non-goals)
- [Principles](#principles)
- [Use Cases](#use-cases)
- [Focusgroup Concepts](#focusgroup-concepts)
  - [Last-focused memory](#last-focused-memory)
  - [Guaranteed tab stop](#guaranteed-tab-stop)
  - [Shadow DOM boundaries](#shadow-dom-boundaries)
  - [Key conflicts](#key-conflicts)
  - [Interactive content inside focusgroups](#interactive-content-inside-focusgroups)
  - [Restricted elements](#restricted-elements)
  - [Feature detection](#feature-detection)
  - [Additional features](#additional-features)
- [Enabling wrapping behaviors](#enabling-wrapping-behaviors)
- [Limiting linear focusgroup directionality](#limiting-linear-focusgroup-directionality)
- [Opting-out](#opting-out)
- [Disabling focusgroup memory](#disabling-focusgroup-memory)
- [Adjustments to sequential focus navigation](#adjustments-to-sequential-focus-navigation)
- [(Future Consideration) Grid focusgroups](#future-consideration-grid-focusgroups)
  - [Applicability to tabular data](#applicability-to-tabular-data)
  - [Setting up a grid focusgroup](#setting-up-a-grid-focusgroup)
  - [Manual grids: row and cell connections](#manual-grids-row-and-cell-connections)
  - [Grid focusgroup nesting](#grid-focusgroup-nesting)
  - [Empty Cell data](#empty-cell-data)
  - [Non-uniform cells](#non-uniform-cells)
- [(Future Consideration) Additional Keyboard support](#future-consideration-additional-keyboard-support)
- [Alternative Scoping Mechanism](#alternative-scoping-mechanism)
  - [Existing Proposal](#existing-proposal)
  - [Alternative scoping](#alternative-scoping)
  - [Avoiding redundant declarations](#avoiding-redundant-declarations)
- [Open Questions](#open-questions)
- [Privacy and Security Considerations](#privacy-and-security-considerations)
  - [Privacy](#privacy)
  - [Security](#security)
- [Design decisions](#design-decisions)
- [Index of focusgroup values](#index-of-focusgroup-values)
- [Acknowledgments](#acknowledgments)
## Introduction

Authors routinely hand-code ‚Äúroving tabindex‚Äù logic for composite widgets like toolbars, tablists, menus, listboxes, and grids. In practice, this means providing a single tab stop to enter the control, then using arrow keys to move focus between items.

## Differences from the original explainer
[Original focusgroup explainer.](/components/focusgroup.explainer)
### CSS Support is now a future consideration.
Support for applying focusgroup and related attributes via CSS is considered out-of-scope for this explainer, but should be considered for a future, backwards compatible, addition.

### Grid Support is now a future consideration.
Support for applying focusgroup and related attributes to grid-like structures is considered out-of-scope for this explainer, but should be considered for a future, backwards compatible, addition.

### Focusgroup is now scoped to specific Scenarios
A broad earlier `focusgroup` explainer generalized this to all elements, but unconstrained usage can be misapplied to arbitrary containers ("div soup"), obscuring missing semantics and creating confusing keyboard loops that degrade accessibility. This version deliberately scopes `focusgroup` to a small, well-defined set of ARIA composite widget roles where:

* Roving tabindex is already an established best practice (alignment with APG patterns).
* Grouped arrow-key navigation is expected by assistive technologies and users.
* The semantic contract (composite widget ‚Üí managed internal focus) is already implied.

Reasons for scoping now:

1. Accessibility integrity: Prevents legitimizing arrow navigation on arbitrary layout containers that lack meaningful relationships, avoiding patterns that flatten or bypass true document structure.
2. Interoperability focus: A smaller, role-bound surface accelerates consistent UA + AT implementation and testing.
3. Author guardrails: Most real implementations (libraries/utilities) already concentrate on these composites; constraining the native feature mirrors current successful practice and reduces accidental misuse.
4. Custom element clarity: Clear initial limits avoid later removals; future expansion criteria can be explicit (e.g., demonstrable accessibility benefit, stable semantics, passing test matrix).
5. Declarative signal quality: Keeping the attribute on contexts with strong semantics maximizes usefulness of the implicit accessibility signal (focus mode switching, predictable navigation expectations).
6. Progressive path preserved: A lower-level or more generic primitive can be layered in later without invalidating this attribute; this approach avoids over-promising broad utility up front.

Future evolution can consider additional roles or a role-agnostic extension when there is objective evidence (author demand + accessible patterns + testable semantics) that expansion improves user outcomes without reintroducing the risks above.

While the need to scope is not an open question in this document, _how to scope_ is. See the [Alternative Scoping Mechanism](#alternative-scoping-mechanism) section for details on another scoping mechanism that is being considered.

### Eligible Roles
* `toolbar`
* `tablist`
* `listbox`
* `menu`
* `menubar`
* [(future consideration) `grid`](#future-consideration-grid-focusgroups)

Authors may use the proposed `focusgroup` HTML attribute to declare that
a subtree of focusable elements will get:
1. focus navigation ([not selection](#non-goals)) using keyboard directional arrow keys (for lists
   or grids).
2. a guaranteed tab stop (when at least one focusable element is present).
3. automatic return to the last focused focusable element.
4. start/end navigation (with Home/End keys).
5. optional limited-axis arrow key navigation and optional wrap-around semantics.

By standardizing `focusgroup`, authors can leverage these behaviors in
[control patterns](https://www.w3.org/WAI/ARIA/apg/) to provide users with keyboard consistency,
default accessibility, and interoperability over existing solutions.

While this document emphasizes the usage of the keyboard arrow keys for accessibility
navigation, we acknowledge that there are other input modalities that work (or can be adapted
to work) equally well for `focusgroup` navigation behavior (e.g., game controllers, gesture
recognizers, touch-based assistive technologies (AT), etc.).

Benefits over ad-hoc scripts (FocusZone, Tabster, bespoke roving tabindex): less boilerplate, standardized axis + wrap behavior (including RTL / vertical), reduced misapplication, and a consistent, testable baseline for AT and UA interoperability.

## Quickstart

The following examples start with the most common composite: a formatting toolbar.

What you can (and do) today (imperative roving tabindex):

```html
<div role="toolbar" aria-label="Text formatting" id="fmtToolbar">
  <button type="button">Bold</button>
  <button type="button">Italic</button>
  <button type="button">Underline</button>
</div>
<script>
  // Without focusgroup you must: manage one roving tab stop, intercept Arrow/Home/End (wrap + RTL), track last focus vs selection-first, skip disabled/hidden, and update on mutations.
</script>
```

Issues with this approach: boilerplate per component, manual wrap & memory bookkeeping, repeated tabIndex writes (layout/AT churn), handling of RTL/vertical writing & Home/End variations, mutation tracking, and risk of divergence across frameworks.

Scoped `focusgroup` replacement (no JS needed for the core navigation + memory + wrap):

```html
<div role="toolbar" focusgroup="wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
```
What to notice:
* `focusgroup` enables down/right arrow keys to advance the focus to the next focusable element in
   DOM order (up/left keys will move the focus in reverse) just like in the native radio group.
* edge wrapping (`wrap`) so users can cycle continuously.
* last-focused memory on re-entry. State and selection changes (e.g., toggling Bold) remain normal button semantics, `focusgroup` never infers or changes selection.

In this next example, the author is using a
[tab control pattern](https://www.w3.org/WAI/ARIA/apg/patterns/tabs/) where the tab activation
behavior is decoupled from selection ("manual tab activation"):

```html
<div role="tablist" focusgroup="inline wrap no-memory" aria-label="Common Operating Systems">
  <button id="tab-1" type="button" role="tab" aria-selected="false" aria-controls="tabpanel-1" tabindex="-1">macOS</button>
  <button id="tab-2" type="button" role="tab" aria-selected="true" aria-controls="tabpanel-2" tabindex="0">Windows</button>
  <button id="tab-3" type="button" role="tab" aria-selected="false" aria-controls="tabpanel-3" tabindex="-1">Linux</button>
</div>
<div id="tabpanel-1" role="tabpanel" tabindex="0" aria-labelledby="tab-1" hidden> ‚Ä¶ </div>
<div id="tabpanel-2" role="tabpanel" tabindex="0" aria-labelledby="tab-2"> ‚Ä¶ </div>
<div id="tabpanel-3" role="tabpanel" tabindex="0" aria-labelledby="tab-3" hidden> ‚Ä¶ </div>
```

What to notice:
* Sequential focus navigation within a `focusgroup` is respected. When entering the `focusgroup`,
   focus will always go to the first selected tab (with `tabindex=0`). The `no-memory` value
   [prevents the focusgroup from remembering the last focused tab](#disabling-focusgroup-memory) so
   that focus will always go to the selected tab on re-entry regardless of which element was
   focused last.
* If focus is moved via left arrow key to `tab-1`, then pressing the tab key moves focus to
   `tabpanel-2` which is next in sequential focus navigation order (because the other
   `role=tabpanel`s are `hidden`).
* focus will `wrap` from one end of the tablist to the other because of `focusgroup=wrap` attribute
   value.
*   the up and down arrow keys **will not** move the focus because of `focusgroup="inline"` which
   restricts the axis of movement to keyboard directional arrow keys in the `role="tablist"`'s
   **inline** direction (assuming the `<div>`'s `writing-mode` is `horizontal-tb`).
*   The author code required to manage the selection of a tab is omitted for brevity. Such code on tab selection
   change would update `aria-selected` values, the `hidden` state of the controlled `role="tabpanel"`
   and the `tabindex` values of tabs such that the newly selected `role="tab"` element is `tabindex="0"`
   while all others are `tabindex="-1"`.

In a third example, the author is creating a
[navigation menubar](https://www.w3.org/WAI/ARIA/apg/patterns/menubar/examples/menubar-navigation/).
Both `menuitem`s in the `menubar` ("About" and "Admissions") have popover `menu`s. The "Admissions"
menu has an additional submenu under "Tuition".

```html
<ul role="menubar" aria-label="Mythical University" focusgroup="inline wrap">
  <li role="none">
    <a role="menuitem" popovertarget="aboutpop" href="‚Ä¶" tabindex="-1" title="">About</a>
    <ul role="menu" focusgroup="block wrap" autofocus id="aboutpop" aria-label="About" popover>
      <li role="none"><a role="menuitem" href="‚Ä¶" tabindex="-1" title="">Overview</a></li>
      <li role="none"><a role="menuitem" href="‚Ä¶" tabindex="-1" title="">Administration</a></li>
    </ul>
  </li>
  <li role="none">
    <a role="menuitem" popovertarget="admitpop" href="‚Ä¶" tabindex="-1" title="">Admissions</a>
    <ul role="menu" focusgroup="block wrap" autofocus id="admitpop" aria-label="Admissions" popover>
      <li role="none"><a role="menuitem" href="‚Ä¶" tabindex="-1" title="">Apply</a></li>
      <li role="none">
        <a role="menuitem" popovertarget="tuitpop" href="‚Ä¶" tabindex="-1" title="">Tuition</a>
        <ul role="menu" focusgroup="block wrap" autofocus id="tuitpop" aria-label="Tuition" popover>
          <li role="none"><a role="menuitem" href="‚Ä¶" tabindex="-1" title="">Undergraduate</a></li>
          <li role="none"><a role="menuitem" href="‚Ä¶" tabindex="-1" title="">Graduate</a></li>
        </ul>
      </li>
      <li role="none"><a role="menuitem" href="‚Ä¶" tabindex="-1" title="">Visit</a></li>
    </ul>
  </li>
</ul>
```

What to notice:
- `focusgroup` declarations can be nested inside of other focusgroups. When a nested focusgroup
   is declared on an element, it creates a new focusgroup and [opts-out](#opting-out) of its
   ancestor focusgroup.
- menuitems in `role=menubar` are limited to inline-direction arrow keys (e.g., left and right),
   while menuitems in `role=menu` are limited to block-direction arrow keys (e.g., up and down).
   This allows the orthogonal arrow keys (e.g., up and down on the menubar, left and right on the
   menus) to be used for activation purposes (extra code that is not shown in the example).
- Placement of focus on the menus (the nested focusgroups) from the menubar is not a feature of
   `focusgroup` (nested focusgroups are completely independent of their ancestor focusgroup). In this
   case, the focus placement is handled by built-in `popover` and `autofocus` attribute behaviors.
- the "memory" of the nested `focusgroup`s is reset when the content is hidden/shown--this allows
   the `autofocus` attribute to pick the first focusable element each time a menu is shown--the
   desired behavior in this case.

Finally, the author is creating a data grid following the
[data grid pattern](https://www.w3.org/WAI/ARIA/apg/patterns/grid/examples/data-grids/) where each
of the cells in the table are focusable.

```html
<table focusgroup="grid" role="grid" aria-label="Transactions">
  <tbody><tr>
    <th>Date</th>
    <th>Type</th>
    <th>Description</th>
    <th>Amount</th>
    <th>Balance</th>
  </tr>
  <tr>
    <td tabindex="-1">01-Jan-16</td>
    <td tabindex="-1">Deposit</td>
    <td><a tabindex="-1" href="#">Cash Deposit</a></td>
    <td tabindex="-1">$1,000,000.00</td>
    <td tabindex="-1">$1,000,000.00</td>
  </tr>
  <tr>
    <td tabindex="-1">02-Jan-16</td>
    <td tabindex="-1">Debit</td>
    <td><a tabindex="-1" href="#">Down Town Grocery</a></td>
    <td tabindex="-1">$250.00</td>
    <td tabindex="-1">$999,750.00</td>
  </tr>
</tbody></table>
```

What to notice:
- `focusgroup=grid` understands table layout and will provide logical cell navigation with arrow
   keys around all the focusable grid cells.
- `<th>` header cells are not made focusable in this example, and so are not navigable by the
   `focusgroup`.
- all focusable elements are declared with `tabindex=-1` to take them out of sequential focus
   navigation. The `focusgroup` ensures that at least one of these focusable elements participates
   in the sequential focus navigation order regardless. The `focusgroup` also remembers the last
   focused element, and returns the user to that element when they re-enter the table via sequential
   focus navigation.

Opt-out subtree (explicit example):

```html
<div role="toolbar" focusgroup="inline wrap">
  <button tabindex="-1">A</button>
  <span focusgroup="none">
    <button tabindex="-1">(Not arrow reachable)</button>
  </span>
  <button tabindex="-1">B</button>
</div>
```
Items inside the `focusgroup="none"` span are skipped by arrow navigation.

What to notice:
* The opt-out subtree removes its focusable descendants from arrow traversal (ancestor toolbar is eligible) but they remain reachable via Tab.
* Arrow navigation treats the subtree as a single gap‚Äîfocus jumps from the item before to the item after.
* Useful for excluding infrequent/disruptive controls (e.g., help buttons) from high-frequency arrow flows.

Empirical misuse in uncontrolled contexts; correct usage clusters around APG-backed widget roles. Scoping lowers ambiguity and accelerates interoperable implementation.

## Goal

The goal of this feature is to "pave the cow path" of an existing authoring practice
(and accessibility best practice) implemented in nearly every Web UI library: the
[roving tabindex](https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets#technique_1_roving_tabindex)
[[react](https://www.npmjs.com/package/react-roving-tabindex),
[angular](https://material.angular.io/cdk/a11y/overview#listkeymanager),
[fluent](https://developer.microsoft.com/en-us/fluentui#/controls/web/focuszone),
[elix](https://component.kitchen/elix/KeyboardDirectionMixin)]].
Note however, that certain design choices have been made to generalize the
behavior so that additional scenarios are possible. See
[comparing roving tabindex and focusgroup](https://docs.google.com/document/d/1cOxjjZdvFfpexiN1x-MpNJLXrmbrR0xp1sRCTbaQ29c/)
for further details.

To achieve this goal, we believe the solution must be available in declarative markup.
If JavaScript is required, then there seems little advantage to using a built-in feature over
what can be implemented completely in author code. Furthermore, a declarative solution provides
the key signal that allows the platform's accessibility infrastructure to make the `focusgroup`
accessible by default:

- signaling to the AT to switch to a
   ["Focus mode"](https://www.accessibility-developer-guide.com/knowledge/screen-readers/desktop/browse-focus-modes/)
   by default, e.g., that the user has entered a type of control group.
- providing a consistent and reliable navigation usage pattern for users with no extra author code
  required.

### Non-Goals

**Selection Management**
In some [control patterns](https://www.w3.org/WAI/ARIA/apg/) (such as radio groups or tablists)
moving the focus to an element also toggles its **selection** state. While some use cases will
require the selection state to follow the focus, in others these need to be decoupled. `focusgroup`
is decoupled from selection. Tracking and changing selection based on focus will require author
code. Note that a related proposal for tracking selection state,
[**CSS Toggles**](https://tabatkins.github.io/css-toggle/), is
[no longer being pursued](https://docs.google.com/document/d/10JxXgeDAJ5zerOdxoWM9ZU9d5iMOdzGJt0EhlhkOkxM/).

**Visual Indicators**
Implementations are welcome to experiment with additional UI (e.g., a "focusgroup focus ring") in
order to help make users aware of focusgroups, however this proposal does not include any
specific guidelines or recommendations.

**Generic Container Navigation**
This explainer proposes that `focusgroup` should be limited to a specific set of roles to ensure we don't encourage confusing or inaccessible behavior.

## Principles

1. Intuitive use in declarative scenarios. Focusgroups
   - are easy to reason about (self-documenting) in the source markup.
   - provide a rational behavior when nested.
   - integrate well with other related platform semantics (e.g., `tabindex`).
2. Focusgroups are easy to maintain and configure.
   - Configuration is managed in one place.
   - Provide easy to understand usage into HTML patterns.
   - Avoid "spidery connections" e.g., using IDRefs or custom names that are hard to maintain.
3. Complimentary declarative representations in HTML
   - HTML attributes offers focusgroup usage directly with impacted content and provide for
     the most straightforward scenarios.

## Use Cases

1. (Element and subtree opt-in) A focusable element with a supported role and its entire subtree can participate in a single `focusgroup`.
2. (Cross Shadow DOM) Focusable elements contained inside a Shadow DOM are discoverable and focusable when their Shadow Host or an ancestor element declares a `focusgroup`.
3. (Wrap) A `focusgroup` can be configured to have wrap-around focus semantics.
4. (Limit directional arrow keys) A `focusgroup` can be configured to respond to either the logical
   [inline-axis](https://drafts.csswg.org/css-writing-modes-4/#inline-axis) navigation keys (e.g.,
   left and right arrow keys when the `focusgroup` is in a `horizontal-tb`
   [writing mode](https://drafts.csswg.org/css-writing-modes/#block-flow)) or
   [block-axis](https://drafts.csswg.org/css-writing-modes-4/#block-axis) navigation keys or both
   (to trivially reserve one axis of arrow key behavior for supplementary actions, such as opening
   nodes in a tree view control). See
   [CSS Logical Properties and Values](https://drafts.csswg.org/css-logical/) for more about logical
   directions.
5. (Focus movement arrow keys follow content direction) The user's arrow key presses move the focus forward or backward in the DOM according to the writing mode and directionality of the content.  E.g., in RTL, an Arrow-Left key moves the focus forward according to the content direction.
6. (Opt-out) Individual elements can opt-out of `focusgroup` participation.
7. (Grid) A `focusgroup` can be used for grid-type navigation (`<table>`-structured content or other grid-like structured content).

A use case we are evaluating:
* (Grid) A `focusgroup` can be used on elements with `display: grid` to provide 2d grid navigation.

## Focusgroup Concepts

A `focusgroup` is a group of related elements that can be navigated by directional arrow keys and
home/end keys and for which the web platform provides the navigation behavior by default. No
JavaScript event handlers needed in many cases! The behavior of arrow keys depends on the content's writing mode. Keys pointing toward the `block-end` or `inline-end` navigate forward, while keys pointing toward `block-start` or `inline-start` navigate backward.

There are two kinds of `focusgroup`s: **linear `focusgroup`s** and **grid `focusgroup`s**.
Linear `focusgroup`s provide arrow key navigation among a _list_ of elements. Grid `focusgroup`s provide
arrow key navigation behavior for tabular (or 2-dimensional) data structures.

* `focusgroup` or `focusgroup=""` (no value) defines a linear `focusgroup`.
* `focusgroup="grid"` defines a grid `focusgroup` (2-D navigation).

Focusgroups consist of a **focusgroup definition** that establishes **focusgroup candidates** and
**focusgroup items**. Focusgroup definitions manage the desired behavior for the associated
focusgroup items. Focusgroup items are the elements that actually participate in the focusgroup
(from the set of focusgroup candidates). Focusgroup candidates are all the elements under the scope
of a focusgroup definition. The **focusgroup scope** consists of the element with the focusgroup
definition and its shadow-inclusive descendants, excluding elements that have opted out.

The minimal focusgroup below demonstrates that the element declaring a focusgroup is also a
focusgroup candidate and (in this case) the single focusgroup item.

```html
<div role="toolbar" focusgroup>
  <button type="button">Only control</button>
</div>
```

Focusgroup candidates become focusgroup items if they are focusable, e.g., implicitly focusable
elements like `<button>` or explicitly made focusable via `tabindex` (e.g., a custom element or
`contenteditable`).

An element can only have _one_ **focusgroup definition** added via the `focusgroup` attribute:

Example (toolbar with multiple items and one roving tab stop):

```html
<div id="ancestor" role="toolbar" focusgroup>
  <button id="one" type="button">Bold</button>
  <button id="two" type="button" tabindex="-1">Italic</button>
  <button id="three" type="button" tabindex="-1">Underline</button>
</div>
```

The `ancestor` element has the **focusgroup definition**. The elements with `id=one`, `two`, and
`three` (and any other shadow-inclusive descendants of `ancestor` that may be added) are
**focusgroup candidates**. Because each of these candidates are focusable, they are also
**focusgroup items**. When one of the focusgroup items becomes focused, the user can move focus
sequentially among all the focusgroup items using the arrow keys (up/right moves focus forward,
down/left moves focus backwards assuming the `<p>` element has `writing-mode` `horizontal-tb` and
`direction` `ltr`).

Note that only elements with `id=one` and `three` can be focused using the Tab key. The `<span>` has
`tabindex=-1` set, which takes it out of the tabindex sequential navigation ordering.

### Last-focused memory

By default, focusgroups will remember the last-focused element, and for sequential focus navigation,
will restore focus to that element when a focusgroup is re-entered. This is important for large
lists or tables so that users are returned the context they previously left without having to
navigate from the start or end sequentially.

The focusgroup's memory is initially empty. In that state, sequential focus navigation will pick
the next element to focus using existing platform behavior
[with the exception noted below](#guaranteed-tab-stop).

The `focusgroup`'s memory is cleared if the last-focused item becomes non-focusable or if its relationship to the `focusgroup` container changes (e.g., it is removed from the DOM). See
[additional details below](#disabling-focusgroup-memory).

### Guaranteed tab stop

Focusgroups provide a special behavior when used in conjunction with sequential focus navigation
("tab navigation"). Focusgroups ensure that **at least one** focusgroup item will participate in
sequential focus navigation even if all focusgroup items are declared to opt-out via `tabindex=-1`.
This behavior ensures that a `focusgroup` can always be entered via sequential focus navigation.
[See below for further details](#adjustments-to-sequential-focus-navigation).
Aside from this one behavior change, there is no other impact to the way tab navigation works with
`tabindex` nor the tab ordering behavior.

Focusgroups can therefore be used to provide a
[roving tabindex](https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets#technique_1_roving_tabindex)
among a set of related focusable controls such as this menubar:

Example:

```html
<div role="toolbar" focusgroup aria-label="Text Formatting" aria-controls="‚Ä¶">
  <div>
    <button type="button" aria-pressed="false" value="bold" tabindex="-1"><span>Bold</span></button>
    <button type="button" aria-pressed="false" value="italic" tabindex="-1"><span>Italic</span></button>
    <button type="button" aria-pressed="false" value="underline" tabindex="-1"><span>Underline</span></button>
  </div>
</div>
```

When pressing tab to enter this "toolbar" focusgroup from an element _before_ it, focus will go to
the first `<button>` because:
- There is no other element within the focusgroup with a `tabindex` >= 0 or that is sequentially
   focusable by default (these `<button>`s are taken out of sequential focus navigation with
   `tabindex=-1`).
- This focusgroup has no "memory" of a last-focused element within (e.g., it has not been entered
   before).
- Since neither of the above cases resulted in focusing an alternate element, then the first
   focusgroup item in the group is focused.

At this point, the user can use the arrow keys to move from the beginning of the toolbar to the end,
or press tab again to move outside of the focusgroup.

Alternatively, `focusgroup` can be used to supplement existing tab-stop behavior to provide arrow key
navigational support **in addition** to tab navigation. No problem: just ensure the desired elements
are sequentially focusable via `tabindex="0"` (or stop excluding them via `tabindex="-1"`):

Example:

```html
<div role="toolbar" focusgroup aria-label="Text Formatting" aria-controls="‚Ä¶">
  <div>
    <button type="button" aria-pressed="false" value="bold"><span>Bold</span></button>
    <button type="button" aria-pressed="false" value="italic"><span>Italic</span></button>
    <button type="button" aria-pressed="false" value="underline"><span>Underline</span></button>
  </div>
</div>
```

### Shadow DOM boundaries

Focusgroup definitions apply across Shadow DOM boundaries in order to make it easy for component
developers to support focusgroup behavior across component boundaries. (Component authors that want
to [opt-out of this behavior](#opting-out) can do so.)

Example:

```html
<list-component focusgroup role="listbox" aria-label="Cute dogs">
  <template shadowrootmode="open">
    <my-listitem role="option" tabindex="0" aria-selected="true">Terrier</my-listitem>
    <my-listitem role="option" tabindex="-1" aria-selected="false">Dalmation</my-listitem>
    <my-listitem role="option" tabindex="-1" aria-selected="false">Saint Bernard</my-listitem>
  </template>
</list-component>
```

### Key conflicts
The focusgroup is a default handler for certain keystrokes (keydown events for arrow keys, home/end,
etc.) that will cause focus to move among focusgroup items. This default keyboard handling could
interfere with other actions the application would like to take. A common pattern is to
[limit focusgroup directionality](#limiting-linear-focusgroup-directionality) so that certain
cross-axis keystrokes won't trigger focusgroup behavior. However, if these doesn't address the use
case, then authors may cancel the focusgroup's default behavior at any time by canceling
(`preventDefault()`) the specific keydown event. Keydown events are dispatched by the currently
focused element, and bubble through the focusgroup ancestor element in most cases.

### Interactive content inside focusgroups

Some built-in controls like `<input type=text>` provide keyboard behaviors that "trap" nearly all
keys that would be handled by the focusgroup. Others such as `<input type=number>` trap only certain
keys like the arrow keys that are also used for focusgroup navigation. This proposal **does not**
provide a built-in workaround to prevent this from happening. Instead, authors are advised to be
sure users can "escape" these elements. Built-in elements provide this via the tab key. Other
strategies might include requiring an "activation" step before putting focus into the interactive
control (and an Esc key exit to leave).

The focusgroup's [memory](#last-focused-memory) may also cause unexpected user interactions if
authors are not careful. For example, without any author mitigations, an interactive control inside
a focusgroup may inadvertently prevent the user from accessing other focusgroup items:

```html
<div role="toolbar" focusgroup aria-label="Font Adjustment" aria-controls="‚Ä¶">
  <label for="font-input">Font</label>
  <div>
    <div>
      <input type="text" id="font-input" role="combobox" aria-autocomplete="both" aria-expanded="false" aria-controls="font-listbox" aria-activedescendant="">
      <button type="button" aria-label="Font List" aria-expanded="false" aria-controls="font-listbox" tabindex="-1">üîΩ</button>
    </div>
    <ul id="font-listbox" role="listbox" aria-label="Font List">
      <li role="option">Ariel</li>
      <li role="option">Monospace</li>
      <li role="option">Verdana</li>
    </ul>
  </div>
  <button type="button" value="bigger" tabindex="-1"><span>Increase Font</span></button>
  <button type="button" value="smaller" tabindex="-1"><span>Decrease Font</span></button>
</div>
```

When the `combobox` input element is focused, it is remembered by the `focusgroup`'s memory.
The `<input>` element traps nearly all keystrokes by default, including the arrow keys that might
have been used to reach the "Increase/Decrease Font" buttons. When the user presses tab, focus
exits the `focusgroup`. Later, when focus re-enters, the `focusgroup` will put focus back on the
`<input>` element (because of its memory), and the cycle continues with no way to get to the two
following buttons via keyboard interaction alone.

Fortunately, there are several solutions to this problem:
- Remove `tabindex=-1` from the "Increase/Decrease Font" buttons.
- Move the "Increase/Decrease Font" buttons before the `combobox`. (Refer to "Avoid including
   controls whose operation requires the pair of arrow keys used for toolbar navigation" in the
   [Toolbar control pattern](https://www.w3.org/WAI/ARIA/apg/patterns/toolbar/).) Additionally,
   [opt-out](#opting-out) the `<input>` control from `focusgroup` participation so that
   arrow keys skip it. Alternatively,
   [turn off the `focusgroup`'s memory](#disabling-focusgroup-memory) so that focus isn't
   automatically returned to the `combobox`.
- Use script to intercept `focusgroup`-related keydown events on the `<input>` and move focus
   manually. Also consider [limiting the `focusgroup`](#limiting-linear-focusgroup-directionality) to
   one axis and reserving the other axis for operating the `<input>`.

### Restricted elements

Because `focusgroup` definitions are intended for grouping related controls, it does not make sense
to provide `focusgroup` functionality on all elements. While the `focusgroup` attribute may be defined
as a global attribute, its applicability is limited to a subset of elements. Only elements with the
[eligible roles](#eligible-roles) support having `focusgroup` applied to them.

The current proposal is to limit `focusgroup` to only the elements whose name match the DOM's
[valid shadow host names](https://dom.spec.whatwg.org/#valid-shadow-host-name) (which are the
elements allowed to call `attachShadow()`). However, `<table>` and some table parts will need to
be an exception in order to properly support grid `focusgroup`s.

### Feature detection

To enable feature detection, the DOM will include a `focusgroup` property, whose existence on
elements is useful for feature detection.

```webidl
partial interface HTMLElement {
  [CEReactions] attribute DOMString focusgroup;
};
```

### Additional features

Focusgroups have the following additional features:

- [Wrap-around semantics](#enabling-wrapping-behaviors) - what to do when attempting to move past
   the end of a `focusgroup`. The default/initial value is `no-wrap`, which means that focus is
   not moved past the ends of a `focusgroup` with the arrow keys. `wrap` and other tabular wrapping
   behaviors are available for `grid` `focusgroup`s.
- [Directional axis limits](#limiting-linear-focusgroup-directionality) - applies to linear
   `focusgroup`s only; respond to arrow keys in one axis only (either up/down or left/right when the
   arrow key pressed matches the corresponding flow of the content). By default, linear `focusgroup`s
   respond to all four arrow keys.
- [`focusgroup` candidacy opt-out](#opting-out) - prevent an element and its
   shadow-inclusive descendants from participating in an anscester's `focusgroup`.
- [Memory opt-out](#disabling-focusgroup-memory) - prevent the `focusgroup` from remembering what the
   last focused element was when focus leaves a `focusgroup`. By default `focusgroup`s remember that
   element and will restore the focus to that element when the `focusgroup` is re-entered via
   sequential focus navigation.

These feature options are applied as space-separated token values to the `focusgroup`
attribute.


## Enabling wrapping behaviors

By default, `focusgroup` traversal with arrow keys ends at boundaries of the `focusgroup` (the start and
end of a linear `focusgroup`, and the start and end of both rows and columns in a grid `focusgroup`).
The following `focusgroup` definition values change this behavior:

| HTML (attribute value) | Applies To | Effect |
|---|---|---|
| (default) `focusgroup=""` | linear | No wrapping; edges are hard stops. |
| `focusgroup="wrap"` | linear | Moving past one end wraps focus to the opposite end. |
| (default) `focusgroup="grid"` | grid | No wrapping; row and column edges are hard stops. |
| `focusgroup="grid wrap"` | grid | Rows and columns wrap within their own row/column (end ‚Üí start of same row/column). |
| `focusgroup="grid row-wrap"` | grid | Rows wrap; columns do not. |
| `focusgroup="grid col-wrap"` | grid | Columns wrap; rows do not. |
| `focusgroup="grid flow"` | grid | Moving past row end jumps to start of NEXT row (and reverse); same for columns. Last row/column flows to first. |
| `focusgroup="grid row-flow"` | grid | Rows flow; columns are hard stops. |
| `focusgroup="grid col-flow"` | grid | Columns flow; rows are hard stops. |
| `focusgroup="grid row-wrap col-flow"` | grid | Rows wrap; columns flow. |
| `focusgroup="grid row-flow col-wrap"` | grid | Rows flow; columns wrap. |

Specifying both `row-wrap` and `row-flow` in one HTML `focusgroup` definition is an author error. Only
one declaration for row behavior is allowed. Similarly for `col-wrap` and `col-flow`.

## Limiting linear focusgroup directionality

In many cases, having multi-axis directional movement (e.g., both right arrow and down arrow linked
to the forward direction) is not desirable, such as when implementing a
[tablist control pattern](https://www.w3.org/WAI/ARIA/apg/patterns/tabs/), in which case it may not
make sense for the up and down arrows to also move the focus left and right. Likewise, when moving
up and down in a vertical menu, the author might wish to use JavaScript to provide other behavior
for the left and right arrow keys such as opening or closing sub-menus. In these situations, authors
can limit the linear `focusgroup` to one-axis traversal.

Note that the following only apply to linear `focusgroup` definitions (they have no effect on grid
`focusgroup`s).

| HTML (attribute value) | Explanation |
|---|---|
| (default) `focusgroup=""` (unspecified) | Items respond to forward/backward movement via both inline and block arrow keys (where they map to forward/back). |
| `focusgroup="inline"` | Items respond only to arrow keys parallel to the inline axis (e.g., Left/Right in `horizontal-tb`). |
| `focusgroup="block"` | Items respond only to arrow keys parallel to the block axis (e.g., Up/Down in vertical menus or vertical writing modes). |

Example:

```html
<tab-group role="tablist" focusgroup="inline wrap">
  <a-tab role="tab" tabindex="0" aria-selected="true" aria-controls="‚Ä¶">‚Ä¶</a-tab>
  <a-tab role="tab" tabindex="-1" aria-selected="false" aria-controls="‚Ä¶">‚Ä¶</a-tab>
  <a-tab role="tab" tabindex="-1" aria-selected="false" aria-controls="‚Ä¶">‚Ä¶</a-tab>
</tab-group>
```

In the above example, when the focus is on the first `<a-tab>` element, pressing either the up or
down arrow key does nothing because the `focusgroup` is configured to only respond to the inline
(left/right in this case) arrow keys.

Because 2-axis directionality is the default, specifying both `inline` and `block` at the
same time on one `focusgroup` is not allowed:

Example:

```html
<!-- This is an example of what NOT TO DO -->
<radiobutton-group focusgroup="inline block wrap" role="radiogroup">
  ‚ö†Ô∏èThis `focusgroup` configuration is an error--neither constraint will be applied (which is actually
  what the author intended).
</radiobutton-group>
```

## Opting-out

`focusgroup` definitions assigned to an element create `focusgroup` candidates that include
the element itself and all its _shadow-inclusive descendant elements_. Any element within that
`focusgroup` scope that is (or becomes) focusable will automatically become a `focusgroup` item
belonging to its ancestor's `focusgroup`.

With such an expansive opt-in behavior, it is important to provide an opt-out for elements or
element subtrees. For example: focusable elements that wish to remain in sequential focus
navigation and have arrow key navigation pass them over; or, components nested across a
Shadow DOM boundary that wish to be excluded from `focusgroup` participation.

Opting-out applies to the element making the declaration as well as its shadow-inclusive
descendants.

To opt-out:

| HTML (attribute value) | Explanation |
|---|---|
| `focusgroup="none"` | Opt-out: this element and its shadow-inclusive descendants are not considered `focusgroup` candidates. |

In the following example of a toolbar, a help section opts-out of `focusgroup` behavior so that any
interactive content inside it is bypassed when arrowing among the primary formatting controls.

Example:

```html
<div role="toolbar" focusgroup="inline wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <span focusgroup="none" aria-label="Help group">
    <button type="button">Help</button>
    <button type="button">Shortcuts</button>
  </span>
  <button type="button" tabindex="-1">Underline</button>
</div>
</div>
```

When a `focusgroup` definition is applied to an element, it implicitly opts out of any ancestor's
`focusgroup`s. This ensures that every element can only belong in one `focusgroup` at a time.

Example:

```html
<ul role="menubar" focusgroup aria-label="Site">
  <li role="none">
    <ul role="menu" focusgroup aria-label="Products">
      <li role="none"><button role="menuitem" tabindex="-1">Item A</button></li>
      <li role="none">
        <ul role="menu" focusgroup aria-label="More">
          <li role="none"><button role="menuitem" tabindex="-1">Sub A1</button></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
```

- The outer menubar `ul[role="menubar"][focusgroup]` defines one `focusgroup` (its direct menuitems would participate when present).
- The first nested `ul[role="menu"][focusgroup]` creates an independent `focusgroup` and is implicitly not part of the menubar's arrow navigation.
- The innermost `ul[role="menu"][focusgroup]` (submenu) defines yet another independent `focusgroup`, likewise not part of its ancestor menu's `focusgroup`; its `menuitem` participates only in that deepest scope.

## Disabling focusgroup memory

By default, when a linear or grid `focusgroup` is defined it includes a "memory" of the
last-focused element within its scope, initially empty. Each time the focus is changed
within a `focusgroup`, the "memory" is updated to refer to that element. This behavior is
akin to the
[roving tabindex](https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets#technique_1_roving_tabindex)
in which the "memory" is the statefull `tabindex="0"` value assigned to the currently
focused element.

In some scenarios it is not desireable to have a `focusgroup` maintain a memory. Usually this
is because there is a more relevant element which should take focus when entering the `focusgroup`
instead of the most-recently-focused element. For example, an active (selected) tab in a
`role="tablist"` container, rather than the last-focused tab (when selection does not follow focus).

To disable the `focusgroup`'s default memory, use the value `no-memory`:

| HTML (attribute value) | Explanation |
|---|---|
| (default) `focusgroup=""` (unspecified) | `focusgroup` remembers the last-focused element and redirects focus to it when entered via sequential focus navigation. |
| `focusgroup="no-memory"` | `focusgroup` will not remember the last-focused element. |

After the `focusgroup`'s memory has been set, it must be cleared whenever any one of the following
change:

* The element with the `focusgroup` definition is `hidden` or un-hidden; or if the currently-remembered
   element is `hidden` or un-hidden.
* The element with the `focusgroup` definition has its `disabled` or `inert` status changed; or if the
   currently-remembered element has its `disabled` or `inert` status changed.
* The element with the `focusgroup` definition is removed from the shadow-inclusive tree; or if the
   currently-remembered element is removed from the shadow-inclusive tree.
* The currently-remembered element stops being focusable (e.g., a `<div>` with a `tabindex` has its
   `tabindex` attribute removed).
* The currently-remembered element is changed to become excluded from the `focusgroup` (through
   `focusgroup="none"` on itself or a shadow-inclusive ancester, or by changing `focusgroup`s: if a new
   `focusgroup` definition appears on itself or one of its shadow-inclusive ancestor elements).

## Adjustments to sequential focus navigation

To ensure that a `focusgroup` always has at least one tab stop in the sequential focus navigation
order, and to provide the appropriate "hook" for a `focusgroup`'s "memory" to redirect focus to the
last-focused element in a `focusgroup`, a change to sequential focus navigation is needed.

This change is intended to ensure that focus is directed to one of the following `focusgroup`
candidates whenever focus enters a `focusgroup`. The first matching condition is always taken:

1. If there is an element in the `focusgroup` memory, focus is set on that element.
2. If there is an element with `tabindex="0"` (or other built-in element with UA-defined keyboard
    focusability like `<input>`, `<button>`, etc.) that is also a `focusgroup` candidate for the
    current `focusgroup`, focus will be set on the first such element in DOM order (regardless of
    the direction of traversal, i.e., via `tab` or `Shift+tab`). Note: this provides authors with a
    predictable "entry" of their choosing within a `focusgroup`.
3. The first focusable element (even if not intended for sequential focus navigation) if sequential
    focus navigation is moving "forward", or the last focusable element if sequential focus
    navigation is traversing "backward".

Specifically, each `focusgroup` definition must maintain a:
* first focusable `focusgroup` candidate - in DOM order, the first focusable element that is also a
   `focusgroup` candidate (e.g., not excluded from `focusgroup` participation or in another `focusgroup`).
* last focusable `focusgroup` candidate - see previous, but the **last** focusable in DOM order.
* first sequentially-focusable `focusgroup` candidate - in DOM order, the first focusable element that
   would participate in sequential focus navigation order (e.g., the element with the lowest
   positive value of `tabindex`, or with `tabindex="0"`, or that is a built-in sequentially focusable
   element that has not opted-out via `tabindex="-1"`).

Algorithmically, during "forward" sequential focus navigation, if the element being considered is:
1. a member of a `focusgroup` AND is the first focusable `focusgroup` candidate of that `focusgroup` THEN:
   1. if the `focusgroup`'s memory is available and not empty, then move focus to the element referred
       to by the `focusgroup`'s memory.
   2. otherwise, if there is NO first sequentially-focusable `focusgroup` candidate in that
       `focusgroup`, then move focus to this element.
2. otherwise, continue with the sequential focus navigation algorithm as normal.

For "reverse" sequential focus navigation, the algorithm is similar, but swap occurances of the
"first focusable `focusgroup` candidate" for "last focusable `focusgroup` candidate".

Because this algorithm applies only when interrogating the first (or last) focusable `focusgroup`
candidate, then any descendants that preceed (or follow) the first (or last) focusable
`focusgroup` candidate that themselves define a `focusgroup` are considered first. In other words,
broad-reaching ancestral `focusgroup`s won't necessarily "steal" focus from descendant `focusgroup`s
during sequential focus navigation.

## (Future Consideration) Grid focusgroups

Some focusable data is structured not as a series of nested linear groups, but as a
2-dimensional grid such as in a spreadsheet app, where focus can move logically from
cell-to-cell either horizontally or vertically. In these data structures, it makes
sense to support the user's logical usage of the arrow keys to move around the data.

Grid navigation is expected to happen within well-structured content with consistent
rows and columns where DOM structure reflects this organization. In `focusgroup` grid
navigation, only the cells in the grid are `focusgroup` candidates and only the focusable
cells become `focusgroup` items. It is not currently possible to use grid `focusgroup`s to
support other focusable tabular parts such as focusable row elements (see
[comment in issue 1018](https://github.com/openui/open-ui/issues/1018#issuecomment-2013053227) for
a possible future addition for this use case).

### Applicability to tabular data

The arrow navigation in the grid (and in the previous non-grid scenarios) should
reflect the accessible structure of the document, not the presentation view made
possible with CSS. For example, it is easy to create views that visually appear
grid-like, but do not make sense to navigate like a grid if considering that the
data model is fundamentally a list, which is how users of accessibility technology
would perceive it. Wrapping a list of contact cards on screen in a grid-like
presentation allows for more content density on screen for sighted users. In that
scenario, arrow key navigation to move linearly (left-to-right following the
line-breaking across each line) through the contents makes sense (especially if
these are alphabetized), but orthogonal movement through the "grid" (up/down when
cards are aligned or in a masonry layout) jumps the focus to seemingly arbitrary
locations. Multi-directional arrow key navigation may seem appropriate for sighted
users that have the visual context only, but are not appropriate for assistive
technology. In the case of the list-presented-as-a-grid scenario, a linear
focusgroup will make the most sense for sighted as well as users with accessibility
needs.

When considering using a grid `focusgroup`, be sure that the data is structured
like a grid and that the structure makes semantic sense in two dimensions (and not
just for a particular layout or presentation).

Tabular data can be structured using column-major or row-major organization. Given
that HTML tables and ARIA attributes for grids (`role="grid"`, `role="row"`, `role="gridcell"`)
only exist for row-major grid types, this proposal does **not define** grid `focusgroup`
organization for column-major data structures (and assumes row-major data structures
throughout).


### Setting up a grid focusgroup

Grid `focusgroup`s can be created "automatically" or manually. Automatic grids use the context
of existing HTML semantics for tables as the structural components necessary to provide grid-based
navigation. Any elements with computed table layout are suitable for an automatic grid (e.g.,
`display: table-row` in place of using a `<tr>` elements).
[Manual grid](#manual-grids-row-and-cell-connections) creation requires
annotating specific elements with their `focusgroup` grid component names.

Note: We are evaluating the suitability for CSS `display: grid` to create automatic grids.

The automatic grid approach will be preferable when the grid contents are uniform
and consistent and when re-using semantic elements for grids (typical). The manual
approach may be necessary when the grid structure is not uniform or structurally
inconsistent (atypical), and involves identifying the parts of the grid on specific
`focusgroup` candidates using CSS.

Elements with the `grid` `focusgroup` definition on the root element of the structural
grid become automatic grid `focusgroup`s. The implementation must attempt to validate
the structure of the grid to ensure it has appropriate row and cell structures. In the
event that the implementation cannot automatically determine the grid structure, then
the definition is ignored (i.e., there is no fallback to a linear grid).

| HTML | Explanation |
|---|---|
| `focusgroup="grid"` | Establishes the root of an automatic grid `focusgroup`. Shadow-inclusive descendants of the automatic grid are identified and assigned `focus-group-type: grid-row` and `focus-group-type: grid-cell` `focusgroup` candidate status automatically. |

Example:

```html
<table aria-label="Tic tac toe grid" role="grid" focusgroup="grid">
  <tr>
    <td tabindex="-1"></td>
    <td tabindex="-1"></td>
    <td tabindex="-1"></td>
  </tr>
  <tr>
    <td tabindex="-1"></td>
    <td tabindex="-1"></td>
    <td tabindex="-1"></td>
  </tr>
  <tr>
    <td tabindex="-1"></td>
    <td tabindex="-1"></td>
    <td tabindex="-1"></td>
  </tr>
</table>
```

The `<table>`'s grid `focusgroup` definition automatically establishes each of its
descendant `<tr>`s as `focusgroup` rows (the parser-generated `<tbody>` is
accounted for) and `<td>`s as `focusgroup` cells. Each `focusgroup` cell is a scope
root for one `focusgroup` item per cell, and the cell and its shadow-inclusive descendants are all
`focusgroup` candidates. Among all `focusgroup` cells, the left/right arrow keys navigate between cells
in the table, and up/down arrow keys will compute the new target based on the DOM position of the
current `focusgroup` candidate cell in relation to the `focusgroup` candidate row.

### Manual grids: row and cell connections

A manual grid is declared in a `focusgroup` definition with the name `manual-grid`.
With a manual grid, the rows and cells must be explicitly indicated using `grid-row` and
`grid-cell`:

| HTML (attribute value) | Explanation |
|---|---|
| `focusgroup="manual-grid"` | Establishes the root of a manual grid `focusgroup`. Shadow-inclusive descendants must be identified explicitly as grid rows and grid cells. |
| `focusgroup="grid-row"` | Must be a shadow-inclusive descendant of a manual grid `focusgroup` root. |
| `focusgroup="grid-cell"` | Must be a shadow-inclusive descendant of a manual grid `focusgroup` root and also a shadow-inclusive descendant of a grid row. |

Cells cannot be descendants of other cells, and rows cannot be descendants of other rows.

Each `focusgroup` candidate will perform an ancestor search to locate its nearest grid structural
component: cells will look for their nearest row, and rows will look for their nearest grid root.

In the following example, the `<my-cell>`s are all meant to be on the same row of the
grid, and the rows are designated by `<my-row>` elements:

Example:

```html
<my-root role="grid" focusgroup="manual-grid">
  <div role="none" class="presentational_wrapper">‚Ä¶</div>
  <my-row role="row" focusgroup="grid-row">
    <first-thing role="gridcell" focusgroup="grid-cell">‚Ä¶</first-thing>
    <cell-container role="none">
      <my-cell role="gridcell" focusgroup="grid-cell">‚Ä¶</my-cell>
      <my-cell role="gridcell" focusgroup="grid-cell">‚Ä¶</my-cell>
    </cell-container>
    <cell-container role="none">
      <my-cell role="gridcell" focusgroup="grid-cell">‚Ä¶</my-cell>
      <my-cell role="gridcell" focusgroup="grid-cell">‚Ä¶</my-cell>
    </cell-container>
  </my-row focusgroup="grid-row">
  <!-- repeat pattern of div/my-row pairs... -->
</my-root>
```

The following non-uniform structure can still have grid semantics added
via `manual-grid`:

Example:

```html
<div role="grid" focusgroup="manual-grid flow">
  <div role="row" focusgroup="grid-row">
    <div>
      <div role="gridcell" focusgroup="grid-cell"></div>
      <div role="gridcell" focusgroup="grid-cell"></div>
    </div>
  </div>
  <div>
    <div role="row" focusgroup="grid-row">
      <div role="gridcell" focusgroup="grid-cell"></div>
      <div role="gridcell" focusgroup="grid-cell"></div>
    </div>
  </div>
  <div>
    <div>
      <div role="row" focusgroup="grid-row">
        <div>
          <div role="gridcell" focusgroup="grid-cell"></div>
          <div role="gridcell" focusgroup="grid-cell"></div>
        </div>
      </div>
    </div>
  </div>
</div>
```

### Grid focusgroup nesting

Unlike linear `focusgroup`s, an automatic or manual grid `focusgroup` requires a small degree of DOM
structure to work correctly. Unless the proper structure exists, the grid `focusgroup` won't work.

Attempts to define new grid or linear `focusgroup`s among the DOM elements that makeup the
structure of a grid `focusgroup` (such as on or between elements defining the root grid
container, the grid-rows and the grid-cells) will be ignored. However new grid or linear
`focusgroup`s **can be defined** on elements that are shadow-inclusive descendants of grid-cell
elements (e.g., that are outside the set of elements making up the grid's DOM structure).

### Empty Cell data

Like linear `focusgroup`s, focus is only set on elements that are focusable. The arrow key navigation
algorithms look for the first `focusgroup` item (in DOM order) of a grid `focusgroup` cell in the
direction the arrow was pressed. Non-focusable grid `focusgroup` candidates of a `focusgroup` cell
are passed over in the search.

### Non-uniform cells

It is entirely possible to have rows with non-uniform numbers of cells. In these
cases, `focusgroup` navigation behaviors may not work as visibly desired. Algorithms
for navigating grid `focusgroup`s will work based on content the grid content structure
as specified. If the algorithms conclude that there is no "next candidate cell" to
move to (e.g., in a grid with two rows, and the bottom row has three cells, and the
top row only two, if the focus is on the 3rd cell, a request to move "up" to the prior
row cannot be honored because there is no "3rd cell" in that row.

## (Future Consideration) Additional Keyboard support

In addition to arrow keys, the `focusgroup` should also enable other navigation keys such as
pageup/down for paginated movement (TBD on how this could be calculated and in what
increments), as well as the home/end keys to jump to the beginning and end of groups.

It might also be interesting to add support for typeahead scenarios (though what values to
look for when building an index would need to be worked out, and may ultimately prove to be
too complicated).

## Alternative Scoping Mechanism

The `focusgroup` attribute is a new HTML attribute that provides a way to define a group of focusable elements that can be navigated using keyboard controls. This attribute can be applied to any HTML element, allowing for greater flexibility in defining focusable regions within a webpage, but to avoid promoting inaccessible behaviors, this document outlines the need to scope functionality to specific scenarios, namely by limiting functionality to elements that have a specified role that is considered ["eligible" for focusgroup](#eligible-roles).
Aria roles are intended to provide semantic meaning and structure, not to influence the behavior of the page itself. For example, the aria-modal doesn't make the element modal, the developer has to do that with JavaScript. The current version of this explainer has `focusgroup`, and html attribute, have its behavior explicitly tied to an aria attribute, the role. This unprecedented behavior may not be desirable, so an alternative scoping mechanism is detailed below.

### Usage as previously explained in this proposal.
```html
<div id="one" role="toolbar" focusgroup="wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
<div id="two" focusgroup="wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
```
What to notice:
* In the second tab list, `focusgroup` behavior will **not** be applied as the element does not specify an eligible role.
* This breaks the convention of aria being semantic-only, and not tied to behavior.

### Alternative scoping approach
```html
<div id="one" role="toolbar" focusgroup="toolbar wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
<div id="two" role="toolbar" focusgroup="wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
```
What to notice:
* In example "one", focusgroup takes a **required** role as an input, which helps to clarify the intended behavior and scope of the focusable elements within the group.
* In example "two", the required role attribute is **not** specified, which means the focusgroup behavior will not be applied.

### Avoiding redundant declarations
```html
<div id="one" focusgroup="toolbar wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
```
What to notice:
* The author chooses to not specify the role, relying solely on the `focusgroup` attribute to convey the intended behavior. This would be the equivalent of using the `role` attribute, but with a more concise syntax.
* While there isn't precedant for aria to influence the behavior of the page past semantic hints, there is precedant for the reverse, and it is expected that html attributes can influence the semantics of the page. For example, the `hidden` attribute is an HTML attribute that influences both the behavior and the semantics communicated to screen readers, but does not have a corresponding ARIA role. This approach allows for a more streamlined and efficient way to define focusable regions without the need for redundant declarations.

### Conflicting role specification
```html
<div id="one" role="menu" focusgroup="toolbar wrap" aria-label="Text formatting">
  <button type="button" tabindex="-1">Bold</button>
  <button type="button" tabindex="-1">Italic</button>
  <button type="button" tabindex="-1">Underline</button>
</div>
<button id="two" role="menu" tabindex="-1">Exit</button>
```
What to notice:
* In the second example, the required role is specified, but the author also explicitly specifies the role. While this is an example of "bad practice", in this example, the div with id="two" will have a computed role of "menu". While a bad practice, this would follow the existing precedent of following the author's intent, see the button with `id="two"`.
## Open Questions

1. **Eligible Roles:** The [list of roles eligible for `focusgroup`](#eligible-roles) is open for discussion, and I am open to input on what should be allowed.
  * MDN documentation includes [a recommendation to **not**](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles) use `grid` and `listbox` as composite widgets, but supporting them here would send a signal that it is OK to use them in this scenario.
  * Are there other roles not listed here that have a strong use case for `focusgroup`?
2. **Grid Support:** The functionality for `grid` and other 2-D navigation has been moved to "Future Considerations" due to its complexity. I am open to discussing how to best implement this functionality in the future including if this should be moved into a separate explainer.
3. **CSS Mappings:** This explainer does not currently define specific CSS mappings for `focusgroup`, but this is an area that could be explored in the future, or if others feel this is integral to the feature, this could be considered to be added back in.
4. **Attribute Functionality and Dependencies:** There are some concerns about the design of the `focusgroup` attribute.
  - This proposal creates a dependency where the `focusgroup` HTML attribute is only valid when a specific ARIA `role` is also present. This creates an unusual link between a native HTML attribute and ARIA semantics. See the [Alternative Scoping Mechanism](#alternative-scoping-mechanism) section for an alternative that reverses the relationship, with focusgroup taking a role as a required input, which then informs the user agent's understanding of the semantic meaning of the group, which can then be exposed to assistive technologies.
  - What are the specific accessibility challenges with the earlier, more general `focusgroup` proposal? It's possible to misuse other ARIA attributes, so what makes `focusgroup` unique in this regard?

## Privacy and Security Considerations

### Privacy

No considerable privacy concerns are expected, but we welcome community feedback.

### Security

No significant security concerns are expected.

## Design decisions

Here is a short list to issue discussions that led to the current design of focusgroup.

* [ocusgroup works across Shadow DOM boundaries by default](https://github.com/openui/open-ui/issues/521)
* [arrow key movement and directionality contraints should be aligned with content direction (add inline/block)](https://github.com/openui/open-ui/issues/522)
* [focusgroup definitions should not be limited to direct-children](https://github.com/openui/open-ui/issues/989)
* [focusgroup should include a memory](https://github.com/openui/open-ui/issues/537)
* [focusgroup should be restricted to some elements only](https://github.com/openui/open-ui/issues/995)

See other [open `focusgroup` issues on Github](https://github.com/openui/open-ui/issues?q=is%3Aissue+is%3Aopen+label%3Afocusgroup).

## Index of focusgroup values

***Focusgroup types:***

| Description | HTML syntax |
|---|---|
| no `focusgroup` | (missing/invalid attribute) |
| linear `focusgroup` | (unspecified value; default value) |
| automatic grid `focusgroup` | `grid` |
| manual grid `focusgroup` root | `manual-grid` |
| manual grid `focusgroup` row | `grid-row` |
| manual grid `focusgroup` cell | `grid-cell` |

***Focusgroup directions:***

| Description | HTML syntax |
|---|---|
| both directions for a linear `focusgroup` | (unspecified value; default value) |
| inline direction for a linear `focusgroup` | `inline` |
| block direction for a linear `focusgroup` | `block` |

***Focusgroup wrapping:***

| Description | HTML syntax |
|---|---|
| no wrap | (unspecified value; default value) |
| wrap | `wrap` |
| flow (grid focusgroups only) | `flow` |
| column specific | `col-wrap`, `col-flow`, `col-none` |
| row specific | `row-wrap`, `row-flow`, `row-none` |

***Focusgroup memory:***

| Description | HTML syntax |
|---|---|
| enable memory | (unspecified value; default value) |
| disable memory | `no-memory` |

***Alternative scoping mechanism (proposed)***
Where `<role name>` is the ARIA role that corresponds to the current element.
See [Alternative Scoping Mechanism](#alternative-scoping-mechanism) for more details.

| Description | Example |
|---|---|
| Role | `<role name>` |

## Acknowledgments

Thanks to everyone who spent time discussing and contributing to the focusgroup design and implementation, including the members of the OpenUI Community Group. Your insights, ideas, and contributions have been indispensable.
